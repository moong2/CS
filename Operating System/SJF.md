**Shortest-Job-First**
현재 대상 프로세스의 길이가 아닌 **다음 프로세스의 길이**에 따라 할당
같은 실행시간에 대하여 [[FCFS]] 사용
특별한 형태의 [[Priority Scheduling]]

![](https://i.imgur.com/O5SqTa5.png)

정렬 순서 : P4 -> P1 -> P3 -> P2
![](https://i.imgur.com/QgZ78re.png)
P1 대기 시간 : 3
P2 대기 시간 : 16
P3 대기 시간 : 9
P4 대기 시간 : 0
> 💡 총 대기 시간 : (3 + 16 + 9 + 0) / 4 = 7

_FCFS를 사용할 경우
P1 대기 시간 : 0
P2 대기 시간 : 6
P3 대기 시간 : 14
P4 대기 시간 : 21
으로 총 (0 + 6 + 14 + 21) / 4 = 10.25의 대기 시간 발생_
### 변형
![](https://i.imgur.com/j493mYc.png)

새로운 프로세스가 들어왔을 때, 현재 실행 중인 프로세스의 실행 시간이 새로 들어온 프로세스의 실행 시간보다 많을 경우,
1️⃣ **비선점형**
현재 실행중인 프로세스의 실행을 지속

![](https://i.imgur.com/m9KTuu9.png)

P1 대기 시간 : 0
P2 대기 시간 : 7 (8 - 1)
P3 대기 시간 : 15 (17 - 2)
P4 대기 시간 : 9 (12 - 3)
> 💡총 대기 시간 : (0 + 7 + 15 + 9) / 4 = 7.75

2️⃣ **선점형**
현재 실행중인 프로세스의 CPU burst를 끝냄

![](https://i.imgur.com/B3Zqdq6.png)

P1 대기 시간 : 9 (10 - 1)
P2 대기 시간 : 0
P3 대기 시간 : 15 (17 - 2)
P4 대기 시간 : 2 (5 - 3)
>💡 총 대기 시간 : (9 + 0 + 15 + 2) / 4 = 6.5
### 원리
1️⃣ 예상 시간에 따라 정렬
- Priority Queue 등을 사용
2️⃣ 새로운 프로세스가 도착하면 예상 실행 시간을 기반으로 큐에 삽입

### 장점
짧은 프로세스의 대기 시간이 감소하기 때문에 **최소 평균 대기 시간**을 제공하므로 최적
### 단점
다음 프로세스의 길이를 정확히 알 수 없음
-> 다음 프로세스의 실행 시간을 예측(Approximate SJF)하는 방법 사용
