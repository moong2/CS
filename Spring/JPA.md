# 정의
- 자바의 ORM을 위한 표준 기술
- 구현체 : Hibernate(JPA의 구현체), Spring JPA, Eclipse Link

> **ORM**
> 자바의 객체와 관계형 DB를 매핑하는 것 -> 상속과 같은 객체 개념과 상속이 존재하지 않는 RDB에 대한 패러다임 불일치 해결
> DB의 특정 테이블이 자바의 객체로 매핑되어 SQL 문을 일일이 작성하지 않고 객체로 구현할 수 있는 프레임워크
> SQL Query를 직접 작성하지 않기 때문에 직관적이고, 개발자가 비즈니스 로직에 집중할 수 있음

| 기준                    | JPA (Java Persistence API)                                                                    | JDBC (Java Database Connectivity)                                                          |
| ----------------------- | --------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------ |
| **추상화 수준**         | 높은 수준의 ORM(Object-Relational Mapping) 제공. 객체와 데이터베이스 테이블 간의 매핑에 초점. | 낮은 수준의 API 제공. SQL 쿼리를 직접 작성하고 실행.                                       |
| **코드 생산성**         | 많은 반복적인 코드를 줄여줌. CRUD 작업 간소화.                                                | 모든 데이터베이스 작업을 위한 상세한 코드 작성 필요.                                       |
| **데이터베이스 독립성** | 데이터베이스 시스템에 독립적. 애플리케이션 코드 변경 없이 다른 데이터베이스로 쉽게 전환 가능. | SQL 쿼리가 특정 데이터베이스에 종속될 수 있음. 다른 데이터베이스로 전환 시 쿼리 수정 필요. |
| **쿼리 언어**           | JPQL(Java Persistence Query Language) 또는 Criteria API 사용.                                 | SQL을 직접 사용.                                                                           |
| **성능 최적화**         | 캐싱, 지연 로딩, 벌크 연산 등 다양한 성능 최적화 기능 제공.                                   | 성능 최적화는 개발자의 책임. 복잡한 쿼리나 세밀한 최적화 가능.                             |
| **직접적인 제어**       | ORM을 통한 간접적인 데이터베이스 제어.                                                        | 데이터베이스 연결과 쿼리 실행에 대한 직접적인 제어.                                        |
| **유지보수**            | 코드의 유지보수가 용이. 객체 중심 접근 방식.                                                  | 직접 작성된 SQL과 데이터베이스 로직으로 인한 유지보수 복잡성.                              |
# 동작 과정
- Java 애플리케이션과 JDBC 사이에 동작
- 개발자가 직접 JDBC API 사용 x -> JPA 내부에서 JDBC API 사용 -> SQL 호출 -> DB 통신

# 특징
## 1. 데이터베이스 독립성
- 특정 데이터베이스에 종속되지 않는 방식으로 설계
- 데이터베이스 교체의 유연성 증가

## 2. 캐싱
- 1차 캐시와 2차 캐시를 제공하여 성능을 향상
- 빈번하게 접근하는 데이터에 대한 읽기 성능 향상
- `@Query()` 사용 시 `@Modifying(clearAutomatically = true)`를 사용하면 영속성 컨텍스트를 clear해주어 1차캐시를 날리고 DB 조회 쿼리를 실행하여 동기화 문제 해결

## 3. 자동 스키마 생성
- 엔티티 클래스에 기반하여 데이터베이스 스키마를 자동 생성

## 4. 지연 로딩 (Lazy Loading)과 즉시 로딩 (Eager Loading)
- **지연 로딩**
	- 연관된 엔티티나 컬렉션을 실제로 사용할 때까지 로딩을 지연
	- 연관된 객체가 자주 사용되지 않을 때 사용 (연관된 객체를 쓸 경우 2번 SELECT 호출)
	- 연관된 데이터를 프록시 객체로 가져옴
- **즉시 로딩**
	- 엔티티를 로드할 때 연관된 엔티티나 컬렉션을 즉시 로드
	- 연관된 객체가 자주 사용될 때 사용
	- 실무에서 자주 사용하지 않음 (조인이 많아짐 -> 예상치 못한 SQL 발생)
	- N + 1 문제 야기
	> **N + 1 문제**
	> 즉시 로딩일 때 쿼리를 1개 날렸는데 연관된 테이블 때문에 N개의 쿼리가 추가적으로 나가는 현상

## 5. JPQL
- SQL과 유사한 쿼리 언어이지만 데이터베이스 테이블이 아닌 엔티티 객체에 기반한다.
- 복잡한 쿼리와 데이터베이스 작업 과정에서 객체 지향적인 데이터 접근이 가능하다.

## 6. 트랜잭션
- CRUD에는 JPA가  transaction을 지원

# 영속성 컨텍스트
- Entity를 영구 저장하는 환경
- Java 영역에서 데이터를 관리하며 DB 접근 역할 수행
## Entity Manager
- 데이터의 상태변화를 감지하고 상황에 맞는 쿼리 수행
- 애플리케이션이 실행될 때 Bean으로 등록됨
- DB 연결이 꼭 필요한 시점에만 연결
	- 1차 캐시에서 조회를 수행하는 경우
	- Entity가 영속화 되어있지만 Transaction commit이 이루어지지 않아 DB에 저장되지 않은 경우
- Thread safe 하지 않음
	- Proxy 패턴을 사용하여 Thread safe 보장
## Entity 생명주기
![](https://i.imgur.com/opD0vop.png)

1. **비영속**
	- 영속성 컨텍스트와 관계가 없는 상태
	- `@Entity` 어노테이션을 갖고 있는 Entity 객체를 생성했을 때에는 영속성 컨텍스트에서 관리하지 않음 -> EntityManager의 `persist(Entity)`를 통해 영속상태로 변경
2.  **영속**
	- 영속성 컨텍스트에서 관리 중인 상태
	- 영속화가 이루어져도 DB에 바로 저장되지 않음 -> `commit`, `flush`가 이루어져야 DB 저장
3. **준영속**
	- 영속 상태였으나, 영속성 컨텍스트에서 분리하여 관리하지 않은 상태가 됨
	- `detach()`, 초기화, 종료가 되면 컨텍스트 내부의 모든 데이터는 준영속 상태가 됨 -> `merge()`를 통해 병합하여 다시 영속상태로 만듦
4. **삭제**
	- `remove()`로 Entity를 영속성 컨텍스트, DB 양쪽 모두 삭제
## 변경 감지 (dirty checking)
1. **CRUD 감지**
2. **쓰기 지연**
	- 업데이트 쿼리를 생성하지 않고, 쓰기 지연 SQL 저장소에 저장
3. **flush(), commit() 발생**
	- 쓰기 지연 SQL 저장소에 있는 쿼리들이 데이터베이스로 전송되어 실제 업데이트가 이루어짐
# N + 1 문제
- Lazy Loading, Eager Loading으로도 N + 1문제를 해결할 수 없음

1. **fetch join** : inner join
2. **entity graph** : outer join
## 데이터 중복 문제
1. **distinct** 사용
2. **LinkedHashSet** 사용 : 중복 제거 + 순서 보장